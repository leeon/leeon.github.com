---
layout: note
title: Design Pattern
tagline: 设计模式总结
group: dev
update: 2013.12.11
---


##迭代器模式 Iterator
###思路

主要是两个方面的思路:

+ 数据集数据集的处理,不需要关注内部
+ 抽象出数据集的特性,接口来处理
 
###意图
封装一个容器的数据集合，提供遍历，访问操作，并且保持数据集内部细节不可见。《Head First 设计模式》中也提到了一个场景，比如我们要处理来自不同模块的数据集，内部实现不同，这个时候设计一个迭代器接口就显得十分重要了。这个模式实际中不经常需要自己写，因为java已经有了很好的实现。

###类图
![](/assets/images/pages/dp-iterator.png)

###实例
可以参照JDK源码中下面三个文件中的实现:

+ ArrayList.java
+ Iterator.java
+ Collection.java

Collection是集合类的统一接口，定义了`iterator`方法，ArrayList是一个List的具体实现（List接口继承自Collection），其包含了一个内部类Itr,Itr就是Iterator接口的一个具体实现。

-------------

##观察者模式 Observer

###思路
来源于生活中的思考，传统的新闻订阅、邮件列表，以及广播机制。

#####分析需求：

+ 抽象观察者为接口，统一方便管理这个观察者列表
+ 约定被监听者的基本行为，通过接口实现
+ 消息传递，约定消息对象
+ 实现松耦合

###意图
实现多个对象对于单个对象的监听。

###类图
![](/assets/images/pages/dp-observer.png)

###实例
比如我们想监听某一个路段交通灯变化情况，然后将最新的交通信息显示在我们的APP里面，就可以利用观察者模式，此时交通数据就是一个Subject，而我们的LightsBoard就是一个观察者。

观察者模式的基本实现在 `org.leeon.pattern.observer`

[Repo连接](https://github.com/leeon/LearnPatterns)

*@See*  
Java中一个典型的应用例子是，窗口事件响应等机制的实验，我们的一个Button组件便是一个Subject，当我们调用<code>mButton.setOnClickListener(someListener)</code>的时候，就是在添加一个订阅者。
 

----------------

##装饰器模式 Decorator

###思路

#####分析需求：

+ 实现现有功能的扩展
+ 不改变原有的结构

这个模式来自于对类的设计原则的思考，即“开放-关闭原则”
> 类应该对扩展开放，对修改关闭

#####问题
+ 虽然解决了继承特性本身的局限性，但是同样的场景下，当扩展不断的增加，装饰器模式也会带来很多`小而多`的类，也同样不方便管理。
+ 装饰器本身就是在不断的叠加功能，其实就是像滚雪球一样，越滚越大。

#####要点
+ 保证被装饰者和装饰器的超类一致
+ 每一个装饰器维护一个被装饰的引用

###意图
在不改变原有结构的基础上，动态的将责任附加到对象上，实现扩展功能，遵循“开发-关闭原则”。
###类图
![](/assets/images/pages/dp-decorator.png)

###实例
假设我们有一个水果商店，顾客可以定制自己的果篮，我们负责编写一个应用，动态的根据果篮的内容提供不同的服务，包括价格计算，清单打印等。

装饰器模式的基本实现在 `org.leeon.pattern.decorator`

[Repo连接](https://github.com/leeon/LearnPatterns)

*@See*  
Java中有装饰器经典的应用，就是`java.io`包中字节流的封装，这里面涉及了很多类。

----------------

##工厂模式 Factory

###思路

#####分析需求：
首先理解什么是*依赖*的概念，大多数情况，在一个类中，我们经常看到`new`这个关键字，每当我们创建一个新的对象实例的时候，我们就对一个新的类产生了依赖，带来的问题是？

+ 代码难以维护
+ 可扩展性差，修改成本高
+ 显然，违背了 *开放-关闭原则* 。

你可能想到了简单的工厂模式来做，在编码中这已经成为了一种习惯，常常是在某个类中封装一个静态方法，经常是这样调用的:

`Factory.createXX();`

这种方式很好的将客户端和对象生产代码隔离开了，这种方式很好的分离了代码中变与不变的部分，但是却不容易扩展。

为了方便阐述工厂模式，我们用一个实际开发的问题来做展示比较好（网络中有很多显示生活中业务的例子，感觉有些牵强，《Head first》的pizza factory是一个不错的例子）。比如在开发输入法的过程中，我们要生成带有不同皮肤样式的键盘。现在有三个问题摆在面前：

+ 键盘有不同的类型，比如数字，符号，字母等（每一个类型的键盘绘制方式不同）
+ 每个键盘都有不同的颜色样式
+ 键盘的类型以后会增加（我们还没有做九键呢！）

#####问题
我们可不想在逻辑代码里看到一大堆的`new`，貌似可以用简单的工厂来解决，但是以后还有不同的键盘类型，难道去修改代码？还有每个键盘的初始化事情可不只是new的问题，还有一些列常规的操作，比如绘图，显示等。

#####设计原则
>依赖倒置

依赖的概念，在前面已经提到过了，主要说倒置。一般我们正常的思维逻辑都是高层组件依赖底层组件，比如一个键盘生成器是一个高层组件，而一个键盘则是底层组件。假如我们直接生成具体的键盘对象，那么随着键盘种类样式的增加，这个依赖就越来越强。

那么一个思考的过程可以这样的去尝试：工厂需要什么？答案是Keyboard，那么首先假设我们有了Keyboard,这下工厂便只依赖一个Keyboard了，显然可以用接口或者抽象类来实现，考虑到一些共同的属性和操作，抽象类更加的合适，如工厂方法模式的类图。


#####要点
+ 工厂方法模式很好的解决了依赖过多的问题
+ 工厂方法在业务逻辑上的优势是方便同一层级新产品的生产（通过实现新的子类）
+ 抽象工厂封装了一组要生产的对象


###意图
####简单工厂
分离客户端和对象初始化代码

####工厂方法模式：
定义一个创建对象的接口，让子类去决定创建什么样的对象，把实例化推迟到子类。

####抽象工厂模式：
定义了生产一组产品的接口。

###类图
简单的工厂

![](/assets/images/pages/dp-factory1.png)

工厂方法模式

![](/assets/images/pages/dp-factory2.png)

抽象工厂模式

![](/assets/images/pages/dp-factory3.png)
###实例
代码中是一个简单的生成输入法键盘的模拟，利用工厂方法生产不同类型的键盘.
装饰器模式的基本实现在 `org.leeon.pattern.factory`

[Repo连接](https://github.com/leeon/LearnPatterns)

*@See*  
Android开发中，很多服务组件的实例化都用了工厂模式


##单例模式 Singleton


-----------
##适配器模式 Adapter
###思路

#####分析需求：

+ 利用现有的一些接口
+ 不改变原来的代码，去适配


这个模式来自于生活中的启发，比如我们购买不同国家版本的手机，充电器和插座有时候会出现不兼容的情况，这个时候如果有一个适配器，就可以解决问题了。比如A和B不兼容，我们给A做一个适配器，使得在B看来，A是同类。


###意图
将一个类的接口，转换为客户期望的另一个接口，让原本不兼容的类可以合作无间。

###类图
![](/assets/images/pages/dp-adapter.png)


[Repo连接](https://github.com/leeon/LearnPatterns)