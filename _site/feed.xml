<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Zephyrus</title>
		<description></description>
		<link>http://atleeon.com</link>
		<atom:link href="http://atleeon.com/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>使用Trello进行任务管理</title>
				<description>&lt;h1 id=&quot;section&quot;&gt;任务管理&lt;/h1&gt;
&lt;p&gt;在 Apple Store 里面搜索关键字 『todo』可以得到大约有上千个应用，它们或重或轻，虽说“总有一款适合你”，但是找到一个完全适合自身的仍然很困难。这很正常，毕竟每个人的生活习惯、工作方式都不相同。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;个人&lt;/h3&gt;
&lt;p&gt;一般我们描述个人的时间管理主要有四个要素 who does what when and where (with whom)。围绕这四个要素的时间管理方式很多，比如 GTD (Get things done)：首先收集 你要做的各种事情，统一放到自己的Inbox里面；处理这些事情，&lt;em&gt;两分钟以内可以完成的事情&lt;/em&gt;立刻去解决，其他的任务进行整理分类；组织代办的任务，也就是将任务组合或者分类，建立任务之间的依赖；定期回顾自己的任务列表。当然最重要的就是最后的执行了。&lt;/p&gt;

&lt;p&gt;上面简短描述了个人时间管理以及GTD的工作流。其实具体步骤并不重要，关键在于找到一种方式来：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有效的组织自己的任务，并且保证执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般做时间管理，都会选择一款甚至多款GTD类应用，我曾用过的GTD类工具最包括最早从Google calendar到之后的Evernote,Wunderlist,Focus等。当然还有很多非常流行的todo类工具包括Any.do Clear等。我的建议是尽量少的依赖个人todo工具。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;团队&lt;/h3&gt;
&lt;p&gt;做项目其实就是多人的时间管理，大家组成了团队。项目管理 ( 本文限定在软件工程领域 ) 比时间管理的范畴更大。这个领域中最著名的软件莫过于Microsoft Project. 它的功能覆盖了时间管理，资源管理，风险管理诸多方面，但是对于现在大多数团队特别是学生或初创团队来讲太“重”了。原因主要有两个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;学习成本高，属于专业软件，需要学习很多新概念&lt;/li&gt;
  &lt;li&gt;更适合瀑布模型开发传统软件，不适合容易变更任务的互联网产品项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文介绍的团队协作工具叫做&lt;a href=&quot;https://trello.com/leeon/recommend&quot;&gt;Trello&lt;/a&gt;，它的原型就是敏捷开发常用到的白板。所以Trello用起来很接近现实，浅显易懂。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://img.chinawin.net/it/433/81005/2.jpg&quot; alt=&quot;敏捷开发白板&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;敏捷开发常用到的白板&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;trello&quot;&gt;认识Trello&lt;/h1&gt;
&lt;p&gt;Trello中有几个基础的概念，理解了也就会使用Trello进行简单的任务管理了。&lt;/p&gt;

&lt;h4 id=&quot;member&quot;&gt;Member&lt;/h4&gt;
&lt;p&gt;一个自然人，项目中的每一个成员都是member&lt;/p&gt;

&lt;h4 id=&quot;organization&quot;&gt;Organization&lt;/h4&gt;
&lt;p&gt;团队，可以包含一个或多个Member，用来分组&lt;/p&gt;

&lt;h4 id=&quot;board&quot;&gt;Board&lt;/h4&gt;
&lt;p&gt;项目白板，就像上面图中的白板一样，这个白板可以分配权限，比如可以把一块board读写权限分配给一个organization，这个组里的成员就都可以阅读和编辑这块白板。在白板里面可以创建不同的List。&lt;/p&gt;

&lt;h4 id=&quot;list&quot;&gt;List&lt;/h4&gt;
&lt;p&gt;任务清单，可以用于任务分类，比如按时间分类，或按照工作性质分类，看具体的需求。前面提到的GTD中的组织其实就是体现在这里。&lt;/p&gt;

&lt;h4 id=&quot;card&quot;&gt;Card&lt;/h4&gt;
&lt;p&gt;具体的任务卡片，就像上面图片中的纸条，写着具体时间地点参与者和具体事项&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-3&quot;&gt;动手实践&lt;/h1&gt;

&lt;p&gt;下面的Slide里面对Trello的基本使用做了介绍，包含了基本的board，list和card的用法。&lt;/p&gt;

&lt;script async=&quot;&quot; class=&quot;speakerdeck-embed&quot; data-id=&quot;86b96360fd0101313e764e83437af169&quot; data-ratio=&quot;1.33333333333333&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;

&lt;h1 id=&quot;section-4&quot;&gt;我的偏好&lt;/h1&gt;
&lt;p&gt;根据自己的习惯，在使用Trello的时候，自己制定了一些规则，当然具体的使用方式还是要看实际的使用场景。原则上，我不会在Trello上记录琐碎的事情，比如吃饭，买东西之类的，这些零碎的东西会记录在之前提到的qq日历或印象笔记中。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;创建分组，为工作分类&lt;/h3&gt;
&lt;p&gt;我的Trello上有三个Organization，分别是公司，自己的团队，以及个人（可以为自己的个人相关的项目创建一个organization，方便对board进行分类管理）,每个organization下面都有多个Board。我的习惯是任何一个计划性的事情都要创建一个Board。&lt;/p&gt;

&lt;p&gt;何为计划性的事情呢？比如要学习一门语言，或者健身学习手绘之类的，这些事情不是一天两天就完成的，需要自己制定好计划有组织的去执行。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;标签分类保持一致&lt;/h3&gt;
&lt;p&gt;Trello里面的label非常有用，你可以用它来标明一个事情的优先级，也可以利用标签过滤，迅速的找到某个优先级的任务，因为每个项目的标签都可以分别定义，所以不容易管理。我的习惯是让所有项目的标签含义保持一致，比如绿色表示做完的，红色表示非常重要，蓝色表示正在做的，黄色表示警告等。&lt;/p&gt;

&lt;h3 id=&quot;memberlabeldue-date&quot;&gt;为每一个任务分配member,label,due-date&lt;/h3&gt;
&lt;p&gt;如果一个任务没有指派member，很容易就被忽视了。指派后的任务，发生变更或者评论，任务成员都会收到通知。label可以用来直观的看到哪些任务是完成的，哪些任务是正在做的。日期的作用有两个：一是提醒，二是可以在个人卡片页面看到所有任务的排期，更方便管理自己的时间分配。&lt;/p&gt;

&lt;h3 id=&quot;review-list&quot;&gt;创建Review List&lt;/h3&gt;
&lt;p&gt;大多事情都需要做好review，时常回顾重要的任务，分析feedback，是一个内化的过程。对重要的事情，我一般会多次的review，因此创建一个Review List，将一些完成的任务拖拽到里面，邀请一起review的member.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;保持大脑清醒，保持自律，工具只是辅助。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
				<pubDate>Sat, 02 Aug 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/write/2014/08/02/use-trello.html</link>
				<guid isPermaLink="true">http://atleeon.com/write/2014/08/02/use-trello.html</guid>
			</item>
		
			<item>
				<title>制作一个日系废纸筒</title>
				<description>&lt;p&gt;上周搬进了新的房子，开始了租房的生活。说起租房，已经期待很久，因为终于可以按照自己的想法去打造一个喜欢的自由空间了。&lt;/p&gt;

&lt;p&gt;周末闲暇处理杂物的时候，突然觉得家里的废纸箱应该利用起来，于是乎一个『做废纸桶』的想法就有了，接下来的问题是我要设计一个怎样的垃圾桶？&lt;/p&gt;

&lt;p&gt;MUJI原研哉在『设计中的设计』中写过，我们都知道杯子是什么样的，但是如果要你设计一个杯子呢？这样我们就加深了对杯子的理解。&lt;/p&gt;

&lt;p&gt;所以制作之前就要想好自己的废纸桶要有那些特点。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;简洁&lt;/li&gt;
  &lt;li&gt;方便提起&lt;/li&gt;
  &lt;li&gt;轻&lt;/li&gt;
  &lt;li&gt;和垃圾袋结合方便&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;材料：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;美的电热水壶的包装盒*1&lt;/li&gt;
  &lt;li&gt;优衣库购物袋*2&lt;/li&gt;
  &lt;li&gt;胶水&lt;/li&gt;
  &lt;li&gt;剪刀&lt;/li&gt;
  &lt;li&gt;双面胶袋&lt;/li&gt;
&lt;/ol&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/uniqlomaterials.jpg&quot; alt=&quot;材料&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;成果&lt;/h3&gt;

&lt;p&gt;最后一起欣赏一下我的纸筒：&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/uniqlo1.jpg&quot; alt=&quot;开始&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;正面在卧室&lt;/p&gt;

&lt;p&gt;底座利用了一块电器箱子中的海绵，这样白色纸筒可以和地面之间保留空隙，防止边缘很快变脏。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/uniqlo2.jpg&quot; alt=&quot;2&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;底座&lt;/p&gt;

&lt;p&gt;白色纸盒适合放在防线充足的房间，与MUJI的东西还是挺搭配的:-)&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/uniqlo3.jpg&quot; alt=&quot;3&quot; style=&quot;max-width:400px;max-height:700px;&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;垂直视角&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/uniqlo4.jpg&quot; alt=&quot;4&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;水平视角&lt;/p&gt;

&lt;p&gt;正前方设计了一个小的挡板，上面的两个纸夹的作用是固定垃圾袋。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/uniqlo5.jpg&quot; alt=&quot;5&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;纸夹&lt;/p&gt;

&lt;p&gt;纸夹的制作使用了优衣库购物袋较厚的部分，同时用双面胶固定，再用封袋的胶袋缠绕。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/uniqlo6.jpg&quot; alt=&quot;6&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;纸夹特写&lt;/p&gt;

</description>
				<pubDate>Mon, 07 Jul 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/write/2014/07/07/make-a-uniqlo-box.html</link>
				<guid isPermaLink="true">http://atleeon.com/write/2014/07/07/make-a-uniqlo-box.html</guid>
			</item>
		
			<item>
				<title>向阳处的她</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;“今天要是夏天就好了”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;电影的最后，在江之岛的海边, 真绪这样说。&lt;/p&gt;

&lt;p&gt;本当作一部普通的日系爱情电影看的，但却有不一样的体会。结束时感触最深的两个地方: &lt;strong&gt;1&lt;/strong&gt;.这部电影的画面是我看过最唯美的，几乎每一帧都是日系摄影的经典。&lt;strong&gt;2&lt;/strong&gt;这部电影讲述了一些值得回味人生的道理。&lt;/p&gt;

&lt;hr /&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/sheinthesun-1.jpg&quot; alt=&quot;开始&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;有剧透&lt;/p&gt;

&lt;p&gt;电影就是在江之岛开始的，小时候的浩介用自己的护身符救起一直小猫。用他的话说是『一见钟情』，然后看见小猫逃走了。后者化作真绪，努力的寻找浩介，正如人的社会关系是复杂的，面对压力，最后逃走的是浩介。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/sheinthesun-2.jpg&quot; alt=&quot;相遇&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;初见&lt;/p&gt;

&lt;p&gt;十年后，偶然的再次相遇背后是真绪的精心准备。原作小说里，作者也许正想用此来感叹人类社会并无那样轻松的『纯爱』。这个复杂的社会里，真绪需要用生命中大部分的时间去找回逃走的浩介。学历，事业，样貌，换回她心中最初的想象的简单的相遇。影片中不断播放的『Wouldn’t it be nice』,是真绪的主题曲，她利用一只猫的生命期限，去努力做好每一件事情，为了『初衷』。&lt;/p&gt;

&lt;p&gt;『我有很努力的学习哦』真绪说这句话的时候，我想到了『初衷』。如同浩介一样的大部分人，在这个社会环境中，很难有有影片中真绪那样『初衷』，并用一生的时间去执着，逃走或许是个好主意。人们有更长的生命，因此不会感受到这种感觉。但是对于生活和自己喜欢的事情，不正是需要这种简单的热情吗？&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/sheinthesun3.jpg&quot; alt=&quot;私奔&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;私奔&lt;/p&gt;

&lt;p&gt;最想做的事，留给最好的年华。&lt;/p&gt;

&lt;p&gt;我看见这世上的平凡和伟大，但凡精彩，必然是追逐『初衷』的时刻。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“这样今天的日落就会更晚一点”&lt;/p&gt;
&lt;/blockquote&gt;

</description>
				<pubDate>Fri, 23 May 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/write/2014/05/23/the-girl-in-the-sun.html</link>
				<guid isPermaLink="true">http://atleeon.com/write/2014/05/23/the-girl-in-the-sun.html</guid>
			</item>
		
			<item>
				<title>WI输入法</title>
				<description>&lt;p&gt;WI输入法 Android 2.0 新一轮内测开始了，上轮内测中，大家提出了很多宝贵的意见，我们进行了BUG的修复以及新的功能添加，改进的版本将带来更加好的体验。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;本次更新：&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;新增自定义空格&lt;/li&gt;
  &lt;li&gt;新增安静模式&lt;/li&gt;
  &lt;li&gt;修复游戏中崩溃BUG&lt;/li&gt;
  &lt;li&gt;修正UI细节&lt;/li&gt;
  &lt;li&gt;修复EMOJI的BUG&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-1&quot;&gt;版本特性：&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;纯净的九键中文输入&lt;/li&gt;
  &lt;li&gt;九键滑动选字母标点&lt;/li&gt;
  &lt;li&gt;全新的LOGO设计&lt;/li&gt;
  &lt;li&gt;增强词库&lt;/li&gt;
  &lt;li&gt;云端新词热点词库推送(设置可以调整更新频率)&lt;/li&gt;
  &lt;li&gt;丰富实用的文本编辑&lt;/li&gt;
  &lt;li&gt;蓝牙键盘支持     &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-2&quot;&gt;参与方式：&lt;/h1&gt;

&lt;p&gt;加入WI输入法官方内测QQ群&lt;/p&gt;

&lt;p&gt;QQ群：228763459 &lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-3&quot;&gt;稳定版本下载&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://wi.hit.edu.cn/im&quot;&gt;官网&lt;/a&gt;  &lt;a href=&quot;http://www.wandoujia.com/apps/com.hit.wi&quot;&gt;豌豆荚&lt;/a&gt;
&lt;a href=&quot;http://as.baidu.com/a/item?docid=5017540&amp;amp;f=web_alad_2_2&quot;&gt;百度应用&lt;/a&gt; 
&lt;a href=&quot;http://m.appchina.com/app/com.hit.wi&quot;&gt;应用汇&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;微信公众账号&lt;/h2&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/app/2014/qcode_weixin.jpg&quot; alt=&quot;logo&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;微信号： WI输入法&lt;/p&gt;

</description>
				<pubDate>Sun, 18 May 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/app/2014/05/18/wi.html</link>
				<guid isPermaLink="true">http://atleeon.com/app/2014/05/18/wi.html</guid>
			</item>
		
			<item>
				<title>且听风吟</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;时光真疯狂，我一路执迷与匆忙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近他常哼起这首歌，特别是晚上走路的时候。校园周围很多街道，唯独他记不得这条路的名字，能想起的只有夏夜摇曳的树影，偶尔轻抚皮肤上汗毛的风，温柔的无法抵抗。&lt;/p&gt;

&lt;p&gt;仿如一零年夏天，那些想不起名字的水泥地，台阶、路口的红绿灯、大院的门，小区，水池，当然，还有一个他确信自己仍记得清楚的冰淇淋店。里面发脾气的，耐心的，烦躁的，喜悦的男男女女中间，一张桌子上，放着一本留言册，胡言乱语。&lt;/p&gt;

&lt;p&gt;青春的梦想，单纯的大多只有梦和想，沉溺的会忘记仲夏的烦躁，身体间的汗味也让人迷醉。说起来，那个夏天好热啊，他们都这么说，你问他有多热，他肯定会说 “我好想去吃冰淇淋啊”。&lt;/p&gt;

&lt;p&gt;放假那天，他淋着大雨匆匆忙忙的叫到一辆的士，拼命钻进去，前往车站。临行前，他想看看窗外，可那车窗模糊的像跌进了深深的水里。后来才知道，这雨水让他的夏天以及相关的一切模糊了一片。&lt;/p&gt;

&lt;p&gt;后来，他试图过去寻找那些台阶啊，小区啊，但是却发现自己从没来过，只有那家冰淇淋店还在。于是他按照自己的记忆挑了个位置，桌子上真的有一本小册子，他确信自己找到了，可那日期拆穿了他。走出店门后，他发现那夏天再也找不见了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;后来，他不知不觉就很忙了。但是他还是常常在想那些被雨冲走的日子呢？他常停下来，猜测这这风中就有线索。&lt;/p&gt;

&lt;p&gt;“这条路究竟是要去哪儿，大风声，像没发生 太多的记忆。。。”他感觉有点凉了，哼着歌走了。&lt;/p&gt;

&lt;p&gt;又后来，他就没再找了。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/story/2014/wind.jpg&quot; alt=&quot;雨&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;Photo by searna&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
				<pubDate>Tue, 13 May 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/write/2014/05/13/listen-to-wind.html</link>
				<guid isPermaLink="true">http://atleeon.com/write/2014/05/13/listen-to-wind.html</guid>
			</item>
		
			<item>
				<title>Python中的元类</title>
				<description>&lt;p&gt;翻译一篇来自StackOverflow的回答，原问题地址&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&quot;&gt;What is a metaclass in Python&lt;/a&gt;. 投票最高的答案非常完整描述了Python Metaclass机制。说起元类，大致可以才想到其作用，关于类的类。&lt;strong&gt;元&lt;/strong&gt;或者&lt;strong&gt;meta&lt;/strong&gt;常用来表示关于一个事物本身的属性。比如一份学生名单，这份数据的格式doc, 字数1000字，这就是这份数据的元数据，而文本描述的学生信息就是具体的数据本身，元数据描述了这份数据。你有可能听说过元编程,道理也是一样，编写去生产代码的程序。那么元类呢？&lt;/p&gt;

&lt;!-- break --&gt;

&lt;p&gt;下面为原文部分&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;类也是对象&lt;/h2&gt;
&lt;p&gt;在理解元类之前，你需要掌握Python中类的概念。Python中对于类的处理借鉴了Smalltalk语言。在大多数编程语言中，类只是用来生成对象的代码，从这方面来讲，Python也是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
...     pass
...
&amp;gt;&amp;gt;&amp;gt; my_object = ObjectCreator() #实例化一个对象
&amp;gt;&amp;gt;&amp;gt; print(my_object)
&amp;lt;__main__.ObjectCreator object at 0x8974f2c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是Python类还有更特殊的身份：类也是对象。当你使用&lt;strong&gt;class&lt;/strong&gt;关键字的时候，Python会执行并创建一个对象.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
...     pass
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在内存中创建一个名字为ObjectCreator的对象.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个对象(类)本身具有创建对象(实例)的能力，因此它成为一个类&lt;/strong&gt;. 但是其本身仍然是个对象，因此:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以将类赋值给一个变量&lt;/li&gt;
  &lt;li&gt;可以复制类&lt;/li&gt;
  &lt;li&gt;可以给类添加属性&lt;/li&gt;
  &lt;li&gt;可以把类作为函数参数传递&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(ObjectCreator) # 你可以打印一个类，因为它也是一个对象
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def echo(o):
... print(o)
...
&amp;gt;&amp;gt;&amp;gt; echo(ObjectCreator) # 也可以把类作为函数参数
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(hasattr(ObjectCreator,&#39;new_attribute&#39;))
False
&amp;gt;&amp;gt;&amp;gt; ObjectCreator.new_attribute =&#39;foo&#39; # 可以给类添加新的属性
&amp;gt;&amp;gt;&amp;gt; print(hasattr(ObjectCreator,&#39;new_attribute&#39;))
True
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreator.new_attribute)
foo
&amp;gt;&amp;gt;&amp;gt; ObjectCreatorMirror = ObjectCreator # 把类赋值给其他变量
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreatorMirror.new_attribute)
foo 
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreatorMirror())
&amp;lt;__main__.ObjectCreator object at 0x8997b4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;动态的创建类&lt;/h2&gt;

&lt;p&gt;因为类也是对象，所以我们可也像创建其他对象那样创建类。首先，可以在函数中使用 &lt;strong&gt;class&lt;/strong&gt; 创建类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def choose_class(name):
...     if name ==&#39;foo&#39;:
...         class Foo(object):
...             pass
...         return Foo # 返回类本身，而不是实例
...     else:
...         class Bar(object):
...             pass
...         return Bar
...
&amp;gt;&amp;gt;&amp;gt; MyClass = choose_class(&#39;foo&#39;)
&amp;gt;&amp;gt;&amp;gt; print(MyClass) # 函数返回一个类而不是实例
&amp;lt;class&#39;__main__.Foo&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(MyClass()) # 可以通过这个类创建对象
&amp;lt;__main__.Foo object at 0x89c6d4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这并不是真正的动态创建，你还是需要自己编写全部所需的代码。因为类也是对象，所以它一定可以通过某种方式生成，当你使用&lt;strong&gt;class&lt;/strong&gt;关键字的时候，Python自动创建对象。但是就像Python中很多机制一样，它允许你自己手动控制。&lt;/p&gt;

&lt;p&gt;还记得&lt;code&gt;type&lt;/code&gt;函数吗？这个有点历史并且很棒的函数可以判断一个对象是什么类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(type(1)) 
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(&quot;1&quot;)) 
&amp;lt;type &#39;str&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(ObjectCreator)) 
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(ObjectCreator())) 
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，&lt;code&gt;type&lt;/code&gt;还有一个完全不同的功能，它可以在运行时创建类。&lt;code&gt;type&lt;/code&gt;可以接受一个描述类的参数，并且返回一个类。(针对不同的参数有两个完全不同功能的函数看起来挺愚蠢。这是Python向后兼容的问题)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;方法工作方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type(name of the class,      
    tuple of the parent class(for inheritance, can be empty),      
    dictionary containing attributes names and values)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyShinyClass(object):
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类可以通过下面的方式创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; MyShinyClass= type(&#39;MyShinyClass&#39;,(),{}) # 返回一个对象
&amp;gt;&amp;gt;&amp;gt; print(MyShinyClass)
&amp;lt;class&#39;__main__.MyShinyClass&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(MyShinyClass()) # 用创建的类实例化一个对象
&amp;lt;__main__.MyShinyClass object at 0x8997cec&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到，我们使用 &lt;code&gt;MyShinyClass&lt;/code&gt;作为类的名字，并且引用它。这个名字可以不同，但是没有必要把事情变得更加复杂(一个就够了吧)。&lt;code&gt;type&lt;/code&gt;方法接受一个字典参数来定义类的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Foo(object):
...       bar = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Foo = type(&#39;Foo&#39;, (), {&#39;bar&#39;:True})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foo可以作为一个正常的类的使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(Foo)
&amp;lt;class&#39;__main__.Foo&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(Foo.bar)
True
&amp;gt;&amp;gt;&amp;gt; f = Foo()
&amp;gt;&amp;gt;&amp;gt; print(f)
&amp;lt;__main__.Foo object at 0x8a9b84c&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(f.bar)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然你也可以继承这个类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FooChild(Foo):
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换成动态写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; FooChild = type(&#39;FooChild&#39;,(Foo,),{})
&amp;gt;&amp;gt;&amp;gt; print(FooChild)
&amp;lt;class&#39;__main__.FooChild&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(FooChild.bar) # bar继承自Foo
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后如果想给自己创建的类添加方法，只要定义一个合适的方法并且将其赋值给类的属性就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def echo_bar(self):
...     print(self.bar)
... 
&amp;gt;&amp;gt;&amp;gt; FooChild = type(&#39;FooChild&#39;,(Foo,),{&#39;echo_bar&#39;: echo_bar})
&amp;gt;&amp;gt;&amp;gt; hasattr(Foo,&#39;echo_bar&#39;)
False
&amp;gt;&amp;gt;&amp;gt; hasattr(FooChild,&#39;echo_bar&#39;)
True
&amp;gt;&amp;gt;&amp;gt; my_foo =FooChild()
&amp;gt;&amp;gt;&amp;gt; my_foo.echo_bar()
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，在Python中我们可以在运行时动态创建类，这就是class关键字真正执行的操作，利用了元类。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;什么是元类&lt;/h2&gt;
&lt;p&gt;元类是用来创建类的，你定义class来创建类，对吧？但是我们了解到Python的类其实也是对象。总之元类就是类的类，你可以用下面的方式描述它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass=MetaClass()
MyObject=MyClass()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道&lt;code&gt;type&lt;/code&gt;方法允许我们做下面的这种事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass= type(&#39;MyClass&#39;,(),{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为type函数实际上是一个元类，Python用它来创建所有对象。你也许会想为什么&lt;code&gt;type&lt;/code&gt;全写成小写而不是&lt;code&gt;Type&lt;/code&gt;，我猜是为了和&lt;code&gt;str&lt;/code&gt;(创建字符串对象的类)，&lt;code&gt;int&lt;/code&gt;(创建整型对象的类)保持一致.你可以通过&lt;strong&gt;__class__&lt;/strong&gt;属性查看。&lt;/p&gt;

&lt;p&gt;Python中一切都是对象，包括所有的字符串，整型 ，函数和类。他们都是通过某个类创建的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age = 35
&amp;gt;&amp;gt;&amp;gt; age.__class__
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name = &#39;bob&#39;
&amp;gt;&amp;gt;&amp;gt; name.__class__
&amp;lt;type &#39;str&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def foo():
pass
&amp;gt;&amp;gt;&amp;gt; foo.__class__
&amp;lt;type &#39;function&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; classBar(object):
        pass
&amp;gt;&amp;gt;&amp;gt; b = Bar()
&amp;gt;&amp;gt;&amp;gt; b.__class__
&amp;lt;class&#39;__main__.Bar&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么 &lt;code&gt;__class__.__class__&lt;/code&gt;代表什么呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; foo.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出元类就是创建类的，你可以给它叫做类工厂，&lt;code&gt;type&lt;/code&gt;是Python的内置元类，当然你也可以创建自己的元类。&lt;/p&gt;

&lt;h2 id=&quot;metaclass&quot;&gt;__metaclass__属性&lt;/h2&gt;

&lt;p&gt;创建一个类的时候，可以给它添加 &lt;code&gt;__classmeta__&lt;/code&gt;属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(object):  
    __metaclass__ = something...
    [...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做，Python就会使用指定的元类创建Foo类。这个要小心处理。你首先要写&lt;code&gt;class Foo(object)&lt;/code&gt;，但是Foo类此时还没有被创建。Python会寻找&lt;code&gt;__metaclass__&lt;/code&gt;的定义，如果找到就是用它创建Foo，如果没有找到，就使用type创建。&lt;/p&gt;

&lt;p&gt;记住下面的步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(Bar):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python会做下面的事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查Foo中是不是有__metaclass__属性&lt;/li&gt;
  &lt;li&gt;如果有，创建一个类对象，名字为Foo,通过__metaclass__指定的类创建&lt;/li&gt;
  &lt;li&gt;如果Python找不到__metaclass__，它会在父类Bar中寻找__metaclass__，重复相同的规则&lt;/li&gt;
  &lt;li&gt;如果在任何父类中都找不到__metaclass__，就会到MODULE中去找，重复相同规则&lt;/li&gt;
  &lt;li&gt;如果还找不到，则使用type创建&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;__metaclass__到底应该放什么呢？就是创建类&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;自定义元类&lt;/h2&gt;

&lt;p&gt;元类的主要目的是动态改变类。常见的使用场景是创建API,你需要根据运行环境创建类。考虑一个笨拙的例子，你希望模块中所有的类属性都改为大写的。这有几种实现方式，其中之一就是在模块中设置__metaclass__。&lt;/p&gt;

&lt;p&gt;这样，模块中所有的类都是通过这个元类创建的，我们只需要告诉元类把所有的类属性改为大写。幸运的是，__metaclass__可以以任何形式调用，不一定是正式的class。&lt;/p&gt;

&lt;p&gt;所以我们用一个简单例子开始，使用函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这个元类接收和type相同的参数
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    &quot;&quot;&quot;    
      返回一个类对象，其属性转换为大写
    &quot;&quot;&quot;
    # 选择不是__开头的属性，并且转换为大写  
    uppercase_attr ={}
    for name, val in future_class_attr.items():
        if not name.startswith(&#39;__&#39;):
            uppercase_attr[name.upper()]= val      
        else:          
            uppercase_attr[name]= val  
    # 使用type创建类
    return type(future_class_name, future_class_parents, uppercase_attr)

    __metaclass__ = upper_attr # 作用于模块中所有的类

class Foo():
    # 我们也可以在这里指定__metaclass__只作用于这一个类
    # 这会影响子类 
    bar =&#39;bip&#39;

print(hasattr(Foo,&#39;bar&#39;))
# Out: False
print(hasattr(Foo,&#39;BAR&#39;))
# Out: True
f = Foo()
print(f.BAR)
# Out: &#39;bip&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在实现相同的效果,使用真实的类作为元类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 注意type和int ，str一样，所以你可以继承它
class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用
    # 这个方法负责创建并且返回对象
    # __init__ 方法只是初始化对象参数
    # 平时很少用 __new__, 除非你想要控制对象的创建
    def __new__(upperattr_metaclass, future_class_name,                 
                future_class_parents, future_class_attr):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return type(future_class_name, future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上这种方式并不是真正的面向对象，我们直接调用了type，没有重载父类的__new__方法，这样改写一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(upperattr_metaclass, future_class_name,                 
                future_class_parents, future_class_attr):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        # 重用type.__new__ method
        return type.__new__(upperattr_metaclass, future_class_name,
                            future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能发现了额外的参数uperattr_metaclass,这个参数是对象方法总是将当前实例作为第一个参数传入。当然我使用的这个名字不够明确，就像self，所有参数都有规定名字，所以真实的元类应该是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(cls, clsname, bases, dct):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return type.__new__(cls, clsname, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用super关键字使代码变得更加清晰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(cls, clsname, bases, dct):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return super(UpperAttrMetaclass,cls).__new__(cls, clsname, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于元类真的就是这么多了，使用元类的代码错综复杂的原因不是因为元类，而是因为你通常使用元类在自省，继承和__dict__这样的变量上进行依赖反转。&lt;/p&gt;

&lt;p&gt;事实上元类在使用一些”黑魔法”时很有用，这也使事情更复杂，但是他们本身很简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拦截一个类创建的过程&lt;/li&gt;
  &lt;li&gt;修改类&lt;/li&gt;
  &lt;li&gt;返回修改后的类&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;为什么使用类做元类而不是函数&lt;/h2&gt;

&lt;p&gt;元类接受任何形式调用（上面显示了两种基本方式，通过函数和类），使用类作为元类显然更加复杂，为什么这样做的？&lt;/p&gt;

&lt;p&gt;原因有几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;意图清晰，当你阅读&lt;code&gt; UpperAttrMetaclass(type)&lt;/code&gt;,你知道接下来要做什么&lt;/li&gt;
  &lt;li&gt;利用面向对象，元类可以继承自元类，覆写父类的方法，元类甚至可以使用元类&lt;/li&gt;
  &lt;li&gt;可以更好的控制代码结构，你不可能用元类处理像上面那样微不足道的例子，通常是处理比较复杂的情景，使用类可以将不同方法封装到一起，是的代码更加容易阅读&lt;/li&gt;
  &lt;li&gt;你可以在&lt;code&gt;__new__&lt;/code&gt;,&lt;code&gt;__init__&lt;/code&gt;,&lt;code&gt;__call__&lt;/code&gt;使用hook，这样可以处理不同的事情，或许你可能喜欢把所有代码写到&lt;code&gt;__new__&lt;/code&gt;里，其他人可能觉得&lt;code&gt;__init__&lt;/code&gt;更方便&lt;/li&gt;
  &lt;li&gt;这东西本来就叫元“类”！&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;到底为什么用元类&lt;/h2&gt;
&lt;p&gt;最大的问题来了，为什么使用这么复杂的特性呢？&lt;/p&gt;

&lt;p&gt;事实上，通常不会使用：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;元类是99%开发者不会考虑的特性，如果你疑惑自己是不是需要他们，那么一般答案是，不需要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;元类的主要用处是创建API,一个典型的例子是Django ORM. 它允许你这样定义类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果你这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guy = Person(name=&#39;bob&#39;,age=&#39;35&#39;)
print(guy.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它就不会返回一个&lt;code&gt;IntegerField&lt;/code&gt;，而是返回一个&lt;code&gt;int&lt;/code&gt;，甚至直接从数据库中读取。这是有可能的，因为&lt;code&gt;models.Model&lt;/code&gt;定义了&lt;code&gt;__metaclass__&lt;/code&gt;，并且它可能会改变你定义的&lt;code&gt;Person&lt;/code&gt;类，使得它Hook到数据库的某个字段。Django将复杂的hook用简单的API呈现，并且使用元类重新创建代码来完成背后真正复杂的工作。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;首先你要知道类是对象，并且可以创建对象，然而事实上类自己也是一个实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Foo(object):pass
&amp;gt;&amp;gt;&amp;gt; id(Foo)
142630324
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python中一切都是对象，他们要么是类的实例，要么是元类的实例。&lt;/p&gt;

&lt;p&gt;type除外。type是它自己的元类，这是在实现层完成的。其次元类是复杂的，你可能不希望使用它进行简单的类变换，你可以使用下面的方式改变类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Monkey patching&lt;/li&gt;
  &lt;li&gt;类装饰器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你需要修改类，99%的情况下，你最好使用上面两个方法，但是99%的情况下，你根本不需要修改类。。。。。&lt;/p&gt;
</description>
				<pubDate>Fri, 14 Mar 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/03/14/trans-python-metaclass.html</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/03/14/trans-python-metaclass.html</guid>
			</item>
		
			<item>
				<title>JavaScript Scoping and Hoisting</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;看到一篇好的文章,忍不住要翻译一下了,本文来自twitter工程师 ben cherry的&lt;a href=&quot;http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html&quot;&gt;JavaScript Scoping and Hoisting&lt;/a&gt;,主要讲解了JavaScript中的变量和函数声明的解析顺序，阅读本文之前,读者最好掌握了JavaScript中变量对象VO、函数声明FD以及函数表达式FE的概念.考虑到作者没有详细解释的部分,我进行了代码演示以及文字补充。翻译不恰当的地方,欢迎交流指出。
&lt;!-- break --&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;你知道下面的JavaScript程序执行后,alert会得到什么结果吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = 1;
function bar() {
    if (!foo) {
        var foo = 10;
    }
    alert(foo);
}
bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案是 10,如果你觉得很意外，那么下面这个可能就会更让你震惊了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 1;
function b() {
    a = 10;
    return;
    function a() {}
}
b();
alert(a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码在浏览器中执行会显示1.为什么呢？尽管这个例子看起来比较奇怪，令人疑惑，但这恰恰正是JavaScript语言的一个强大的特性.我不知道是不是有一个标准的名字来描述这种机制，但是我喜欢用“hoisting”这个词.这篇文章将会解开这种机制(hoisting)的面纱。开始之前，先让我们先去理解一下JavaScript的作用域吧.&lt;/p&gt;

&lt;h2 id=&quot;javascript&quot;&gt;JavaScript中的作用域&lt;/h2&gt;

&lt;p&gt;对于JavaScript初学者来讲，最容易迷惑的就是作用域。事实上，不仅仅是初学者，我遇到过很多有经验的JavaScript程序员也不完全理解作用域。JavaScript的作用域如此难以理解的原因或许是它看起来像C语言家族的语言，看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
    int x = 1;
    printf(&quot;%d, &quot;, x); // 1
    if (1) {
        int x = 2;
        printf(&quot;%d, &quot;, x); // 2
    }
    printf(&quot;%d\n&quot;, x); // 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序的输出是1,2,1.原因是C语言以及其家族语言，拥有块级作用域。当程序进入一个块区域，比如if-else语句的时候，一个新的作用域就被创建了，你可以在里面定义新的变量，而不会影响其他作用域。但这种机制并不适用于JavaScript，看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 1;
console.log(x); // 1
if (true) {
    var x = 2;
    console.log(x); // 2
}
console.log(x); // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在firebug中会显示1，2，2.这是因为JavaScript拥有函数级的作用域，这与C家族的语言非常不同。在JavaScript中块，例如if语句，不会创建一个新的作用域，只有函数才会创建新的作用域。&lt;/p&gt;

&lt;p&gt;对于许多习惯了C, C++, C# 或者 Java这样的语言的程序员，这个特性显得很不友好。幸运的是，得益于JavaScript函数的灵活性，还是有变通方法的，如果你需要在函数内部创建一个临时的作用域，可以使用（立即执行函数表达式IIFE）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    var x = 1;
    if (x) {
        (function () {
            var x = 2;
            // some other code
        }());
    }
    // x is still 1.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法其实非常灵活，你可以在任何地方创建临时的作用域，不仅仅是块语句中。然而，我强烈建议花点时间真正的理解和接受JavaScript作用域。它非常的强大，并且是我最喜欢的JavaScript特性之一。如果你理解了作用域，那么hoisting就更容易理解了。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;声明, 变量名, 和声明提升&lt;/h3&gt;

&lt;p&gt;在JavaScript中一个变量名可以通过下面四个方式进入一个作用域:(也就是被当前作用域识别)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;语言内置定义Language-defined：所有作用域都默认包含this 和 arguments变量。&lt;/li&gt;
  &lt;li&gt;函数形式参数Formal parameters：函数可以拥有形式参数,并且在其函数体作用域内生效。&lt;/li&gt;
  &lt;li&gt;函数声明Function declarations：形如function foo() {}的声明。&lt;/li&gt;
  &lt;li&gt;变量声明Variable declarations: 形如var foo;的声明。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数声明和变量声明总是被JavaScript解释器移动到作用域的顶部(hoisting).函数的参数和语言内置定义的变量很显然在这之前已经在那了。这意味着下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    bar();
    var x = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实被解释成了这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    var x;
    bar();
    x = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一种情况是声明所在的语句根本不会执行，但这并不影响hoisting机制,下面两个函数就是等效的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    if (false) {
        var x = 1;
    }
    return;
    var y = 1;
}
function foo() {
    var x, y;
    if (false) {
        x = 1;
    }
    return;
    y = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意有时声明和赋值会一起写，但是赋值部分并不会&lt;strong&gt;提升(hoist)&lt;/strong&gt;，只有变量名会被提升。对于函数声明，整个函数名和函数体都会得到提升。但是记住函数声明有两种方式，思考下面的JavaScript代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test() {
    foo(); // TypeError &quot;foo is not a function&quot;
    bar(); // &quot;this will run!&quot;
    var foo = function () { // function expression assigned to local variable &#39;foo&#39;
        alert(&quot;this won&#39;t run!&quot;);
    }
    function bar() { // function declaration, given the name &#39;bar&#39;
        alert(&quot;this will run!&quot;);
    }
}
test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情形下，bar函数声明的函数体被提升到顶部了,foo这个变量被提升了，但是他对应的函数体仍在原来的位置，执行到那里的时候才会赋值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;补充：原作者在这里并没有详细的介绍函数声明FD和函数表达式FE的概念，上面代码中bar对应的是一个函数声明，而foo对应的语句是一个函数表达式。bar所在的语句是一个完整的函数声明，所以会全部得到提升，而foo所在的语句严格来讲并不是一个函数声明，他可以分为两部分：一是声明了一个普通变量foo,然后把一个函数赋值给foo.因此声明foo变量的语句会提升，而后面的函数部分则不会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面包含了hoisting的基本概念，看起来并不是那么复杂令人疑惑.当然在一些特定的场景下，还是有点复杂的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;变量识别顺序&lt;/h2&gt;

&lt;p&gt;我们要记住的重要的特例是变量的识别顺序。前面提到过变量名进入作用域有四种方式。刚刚我们列出的顺序就是他们被识别的顺序。通常，如果一个变量名已经被定义了，它就不会被另一个相同名字的变量覆盖(后者被忽略)。这意味着函数声明比函数变量声明有着更高的优先级。但是这并不影响对这个变量的赋值会继续进行，只是声明部分被忽略了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;补充一段代码，表达原作者的意思：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function foo(){}
var foo = 3;
console.log(foo);//3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子会被解释器解释为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){}
//var foo;  //这条语句就被忽略了。
foo = 3;
console.log(foo) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接原文，当然也有一些例外:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内置的变量arguments表现的比较怪异。它看起来优先级位于函数形式参数和函数声明之间，这意味着如果形式参数中存在一个叫做arguments的变量，将比语言内置的arguments拥有更高的声明优先级.这是一个不好的特性，不要使用arguments作为形式参数。&lt;/li&gt;
  &lt;li&gt;在任何地方使用this作为标示符都会导致一个语法错误，这是一个好的特性。&lt;/li&gt;
  &lt;li&gt;如果多个形式参数拥有相同的名字，那么最后一个将拥有最高的优先级，即使它是undefined。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;带有名字的的函数表达式&lt;/h2&gt;

&lt;p&gt;你也可以给函数表达式中的函数起一个名字，采用类似函数声明的语法。但这并不能使它变成一个函数声明，并且这个名字也不会添加到作用域，函数体也不会被提升。下面的代码演示了我所说的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo(); // TypeError &quot;foo is not a function&quot;
bar(); // valid
baz(); // TypeError &quot;baz is not a function&quot;
spam(); // ReferenceError &quot;spam is not defined&quot;

var foo = function () {}; // anonymous function expression (&#39;foo&#39; gets hoisted)
function bar() {}; // function declaration (&#39;bar&#39; and the function body get hoisted)
var baz = function spam() {}; // named function expression (only &#39;baz&#39; gets hoisted)

foo(); // valid
bar(); // valid
baz(); // valid
spam(); // ReferenceError &quot;spam is not defined&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;用这些知识编程&lt;/h2&gt;

&lt;p&gt;现在你已经理解了作用域和声明提升，这对于JavaScript编程意味着什么呢？最重要的就是你应该总是使用&lt;strong&gt;var&lt;/strong&gt;关键字来声明变量。我强烈的建议你在每一个作用域的顶部恰好写一个var语句(多变量的时候，用逗号连接)。如果你要求自己这么做，就不会遇到hoisting相关的困惑了。不过，这么做会让你寻找当前作用域中声明的变量变得更困难。我建议使用JSLint的onevar选项来加强这些，例如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*jslint onevar: true [...] */
function foo(a, b, c) {
    var x = 1,
        bar,
        baz = &quot;something&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;标准怎么说&lt;/h2&gt;

&lt;p&gt;我发现通常直接参考&lt;a href=&quot;http://www.mozilla.org/js/language/E262-3.pdf&quot;&gt;ECMAScript Standard (pdf)&lt;/a&gt; 来理解这些机制非常的有效。这是标准中关于变量定义和作用域的描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果变量语句出现在一个函数声明内部，涉及的变量就会定义在函数内部作用域,参考章节10.1.3. 否则，他们就会被定义在全局作用域内(作为global对象的一个属性)，参考章节 10.1.3。 变量在进入作用域的时候被创建。一个block不能定义一个执行环境作用域。只有程序和函数声明可以创建作用域。变量在创建的时候会被初始化为undefined。一个带有初始化语句的变量在赋值语句执行的时候才会被赋上其赋值表达式对应的值，赋值并不是发生在变量创建的时候。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;读完这篇文章建议去知乎上challenge一下这个&lt;a href=&quot;http://www.zhihu.com/question/22949631&quot;&gt;问题&lt;/a&gt;：） &lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;

</description>
				<pubDate>Thu, 06 Mar 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/03/06/javascript-scoping-hoisting.html</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/03/06/javascript-scoping-hoisting.html</guid>
			</item>
		
			<item>
				<title>JavaScript 中的DOM事件</title>
				<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;本文描述的 事件 是W3C定义的API, 这些事件应用在JavaScript对于DOM的操作（Node.js中也有相应的事件机制）。事件主要是监控发生在DOM元素上面的行为，当一个元素的状态改变的时候，比如点击了页面上的某个标签，就会触发事件。&lt;/p&gt;

&lt;!-- break --&gt;

&lt;h2 id=&quot;basic-concepts&quot;&gt;Basic Concepts&lt;/h2&gt;

&lt;h3 id=&quot;document&quot;&gt;document&lt;/h3&gt;
&lt;p&gt;首先回顾一下DOM(Document Object Model)相关的一些基本概念。HTML文档是一棵树的形式组织的，不同的标签被转换成一个节点,这是有了这些节点，JavaScript才能自如的操作页面元素。比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;My Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;Header&amp;lt;/h1&amp;gt;
  &amp;lt;p&amp;gt;Paragraph&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器在渲染这个页面的时候，会以树的形式组织页面，如下图：&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/code/2014dom-tree.jpeg&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;DOM结构&lt;/p&gt;

&lt;p&gt;可以看到树根元素就是&lt;code&gt;document&lt;/code&gt;,表示整个文档对象，通过它可以操作dom节点。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var elem = document.getElementById(&#39;button&#39;);
var newELem = document.createElement(&quot;div&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;window&quot;&gt;window&lt;/h3&gt;
&lt;p&gt;window是JavaScript中的全局变量，所有的全局变量都作为window的属性存在。使用window也可以监控浏览器的窗口事件。例如下面的代码可以关闭浏览器窗口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;eventtarget&quot;&gt;EventTarget&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;EventTarget is a DOM interface implemented by objects that can receive DOM events and have listeners for them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;EventTarget是定义的一个接口，通过这个接口，实现对于DOM事件的支持。Element,document,和window都是最常用的EventTarget，他们还支持on..（如onCLick,现代浏览器推荐addEventListener方法）事件绑定。EventTarget还包括XMLHttpRequest,AudiNode和AudioContext等。&lt;/p&gt;

&lt;p&gt;EventTarget提供三个重要的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;target.addEventListener(type, listener[, useCapture]);&lt;/li&gt;
  &lt;li&gt;target.removeEventListener(type, listener[, useCapture]);&lt;/li&gt;
  &lt;li&gt;canceled = !target.dispatchEvent(event);&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;using-built-in-events&quot;&gt;Using built-in events&lt;/h2&gt;

&lt;p&gt;大多数场景下，我们只需要使用内置的事件类型就足够了。DOM API提供的事件比较丰富，常用的有:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;鼠标事件 &lt;code&gt;mousedown&lt;/code&gt;,&lt;code&gt;mouse up&lt;/code&gt;,&lt;code&gt;click&lt;/code&gt;,&lt;code&gt;mouseover&lt;/code&gt;,&lt;code&gt;mouseout&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;键盘事件 &lt;code&gt;keypress&lt;/code&gt;,&lt;code&gt;keydown&lt;/code&gt;,&lt;code&gt;keyup&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;表单事件 &lt;code&gt;select&lt;/code&gt;,&lt;code&gt;change&lt;/code&gt;,&lt;code&gt;submit&lt;/code&gt;,&lt;code&gt;focus&lt;/code&gt;,&lt;code&gt;reset&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;页面事件 &lt;code&gt;load&lt;/code&gt;,&lt;code&gt;scroll&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假如我们的网页有下面的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;a id=&quot;bt&quot; href=&quot;octsky.com&quot;&amp;gt;Click me!&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js代码中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var bt = document.getElementByIn(&#39;bt&#39;);

function myClickHandler(e){
    alert(&#39;button is clicked.&#39;);
}

bt.addEventListener(&#39;click&#39;,myClickHandler,false);

//you can also do this:
//bt.onclick = myClickHandler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中有两个不同的绑定事件的方法，重要的区别在于第二种通过onclick赋值的方法只能给一个元素绑定一个事件，而addEventListener的方式可以实现多个事件的绑定。&lt;/p&gt;

&lt;p&gt;当我们点击&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签的时候，浏览器会出现弹窗，然后页面跳转至&lt;code&gt;octsky.com&lt;/code&gt;的页面，如果我们不希望页面跳转，阻止a标签的默认行为，使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;e.preventDefault();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;e&lt;/code&gt;是，作为Event Handler函数，默认传入的参数，代表事件本身，并且可以通过他获得事件的一些属性。&lt;/p&gt;

&lt;h2 id=&quot;creating-and-triggering-events&quot;&gt;Creating and triggering events&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    var button = document.getElementById(&#39;button&#39;);
    var event = new Event(&#39;go&#39;);
    
    // Listen to the event
    button.addEventListener(&#39;go&#39;,function  (e) {
        alert(&#39;in go event&#39;);
    },false);
    
    // Dispatch the event
    button.dispatchEvent(event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码创建了一个自定义事件，并且绑定到了&lt;code&gt;button&lt;/code&gt;这个dom元素上，最后手动触发事件执行。这种方法大部分的现代浏览器都支持。注意addEventListener()最后一个参数，false表示不使用事件捕获，后面介绍。&lt;/p&gt;

&lt;h2 id=&quot;event-capture--bubble&quot;&gt;Event Capture &amp;amp; Bubble&lt;/h2&gt;

&lt;p&gt;前面提到了事件捕获，事件捕获是一种事件传递的机制，DOM中主要有两种事件的传递机制:&lt;strong&gt;事件捕获&lt;/strong&gt;和&lt;strong&gt;事件冒泡&lt;/strong&gt;。前者的浏览器支持不完整，后者比较完整。&lt;/p&gt;

&lt;p&gt;二者的主要区别从图中可以看出，当一个element被click的时候，如果使用事件捕获，dom跟元素document会创建事件流，一直向树叶节点元素传播，捕获事件(Capture phase),直到找到真正触发事件的目标元素，过程中，只有目标元素的事件onclick事件会在目标阶段（Target phase）触发。如果使用事件冒泡，事件从目标元素发起，向上传播，直到某个节点调用了阻止冒泡，或者到达了跟节点。过程中经过的element的click事件都会被触发，（这是事件委托的原理）。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/code/2014event-model.jpg&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;事件冒泡与捕获&lt;/p&gt;

&lt;p&gt;addEventListener方法默认关闭事件捕获，开启事件冒泡。如果阻止事件冒泡可以使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event.stopPropagation();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;event-delegation&quot;&gt;Event delegation&lt;/h2&gt;

&lt;p&gt;事件委托是什么概念呢？一个常用的场景是列表管理。列表里有很多元素，并且是动态变化的（比如web版的文件管理器）.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul id=&quot;file-list&quot;&amp;gt;
    &amp;lt;li&amp;gt;item&amp;lt;/li&amp;gt;
    &amp;lt;!--many other--&amp;gt;
    &amp;lt;li&amp;gt;item&amp;lt;/li&amp;gt;   
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果给每一个li元素绑定事件会非常的难以管理，这个时候利用冒泡机制的原理，可以绑定事件给&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;元素，他的每一个子元素事件触发的时候都会冒泡到父元素。再由&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;统一处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var filelist = document.getElementById(&#39;file-list);
filelist.addEventListener(&#39;click&#39;,function(e){
    if(e.target){
        //do something special
    }
},false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：事件委托的前提是使用事件冒泡。&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;本文介绍了JavaScript DOM事件的一些基础的概念，Event是DOM的核心内容，理解基本的概念可以更好的使用一些高级的框架。&lt;/p&gt;

&lt;p&gt;推荐阅读 &lt;a href=&quot;http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture&quot;&gt;W3c DOM Event architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;

</description>
				<pubDate>Sat, 01 Mar 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/03/01/javascript-event.html</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/03/01/javascript-event.html</guid>
			</item>
		
			<item>
				<title>JavaScript中的 变量、作用域链、执行上下文</title>
				<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;之前一直在前端使用JavaScript,主要是操作DOM实现网页中特定的效果。接触Node.js后，JavaScript就开始在Server和Desktop上发挥作用。本文梳理一下JavaScript的一些语法上的几个核心概念,并通过一些例子来加深理解。&lt;/p&gt;

&lt;!-- break --&gt;

&lt;h2 id=&quot;execution-context&quot;&gt;Execution context&lt;/h2&gt;

&lt;p&gt;Execution context (简称EC) 是一个虚拟的概念，区分了不同的代码片段以及执行环境。JavaScript中的代码环境主要有三种，分别是Global Code, Function Code和Eval Code. 其中Global code是&lt;code&gt;.js&lt;/code&gt;文件中直接执行的代码，或者&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中的内容。Function code是进入函数调用时候进入的代码环境。Eval code 是指使用&lt;code&gt;eval()&lt;/code&gt;的代码内容。&lt;/p&gt;

&lt;p&gt;在程序运行过程中，一系列的 execution context 构成了一个context stack。比如，程序一开始就进入了Global context，存在栈底。每当进入一个新的context，就会压栈，栈顶的内容是当前活跃的context。下图演示了context stack的变化。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/ec-stack-changes.png&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Execution context 包含了主要三个部分，Variable object,Scope Chain和this. JavaScript运行时记录和查找变量就是依靠的这些结构。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/execution-context.png&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;vo--ao&quot;&gt;VO &amp;amp; AO&lt;/h2&gt;

&lt;h4 id=&quot;variable-object-vo&quot;&gt;Variable Object （VO）&lt;/h4&gt;

&lt;p&gt;vo是一个与context相关联的一个特殊的object。所谓关联，就是VO存储着在当前context中声明的变量和函数声明（注：是FD而非FE）,当程序试图寻找某一个变量的时候，就会首先检查VO.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = 10;
function bar() {} // function declaration, FD
(function baz() {}); // function expression, FE
 
console.log(
  this.foo == foo, // true
  window.bar == bar // true
);
 
console.log(baz); // ReferenceError, &quot;baz&quot; is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图显示了上面代码，Global context中VO的属性，即变量声明，和函数bar的声明，而没有baz.因为后者属于函数表达式。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/variable-object.png&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于变量声明，必须使用&lt;code&gt;var&lt;/code&gt;关键字.”全局”的声明方式，只是给Global添加了一个属性，并没有严格的声明变量，也不会添加到VO,下面的代码可以验证，因为JavaScript中变量有can’t delete的特性，所以是不能删除的，而属性可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var temp1 = 1; //declare a variable
temp2 = 2; //actually add a new attribute to global

delete temp1;//false 
delete temp2; //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;activation-object-ao&quot;&gt;Activation Object （AO）&lt;/h4&gt;

&lt;p&gt;在函数环境中，VO就变成了AO. 并且增加了函数参数的列表。如下面的代码对应的AO。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(x, y) {
  var z = 30;
  function bar() {} // FD
  (function baz() {}); // FE
}
foo(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/activation-object.png&quot; alt=&quot;&quot; style=&quot;max-width:300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JavaScript代码运行分为两个阶段，&lt;code&gt;entering the execution&lt;/code&gt; 和 &lt;code&gt;code execution&lt;/code&gt;.VO/AO在第一个阶段会被初始化，所以FD函数声明，会在第一个阶段加入到VO/AO，而FE函数表达式则不会。 &lt;/p&gt;

&lt;h2 id=&quot;scope-chain&quot;&gt;Scope Chain&lt;/h2&gt;

&lt;p&gt;作用域链是用于JavaScript寻找变量的结构，由一系列的对象组成，如果一个变量在自己所在的Scope中找不到，也就是自己VO/AO没有，（可以看出，自己的VO/AO）是作用域链的顶端）就去父节点的VO/AO去寻找。根据这个原理，JavaScript中的作用域和其他高级编程语言（利用Block区分作用域）不同，通过函数调用决定作用域链，因为函数调用会创建新的VO/AO.本Scope内不存在的变量叫做&lt;code&gt;free variable&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10;
 
(function foo() {
  var y = 20;
  (function bar() {
    var z = 30;
    // &quot;x&quot; and &quot;y&quot; are &quot;free variables&quot;
    // and are found in the next (after
    // bar&#39;s activation object) object
    // of the bar&#39;s scope chain
    console.log(x + y + z);
  })();
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/scope-chain.png&quot; alt=&quot;&quot; style=&quot;max-width:300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是JavaScript中的作用域链是静态的，当函数被创建的时候，其作用域链就是foo.[[scope]],其中[[scope]]就是globalContext.VO,当函数激活（被调用）的时候，其作用域链为AO+[[scope]].
下面的代码可以看出，foo在创建的时候,其作用域链中并没有 invokeFoo.AO，而是在其创建时刻的globalContext.VO.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 1;
function foo () {
    console.log(x);
}

function invokeFoo(){
    var x = 2;
    foo();
}
invokeFoo(); // we get 1 here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个经典的例子是循环绑定函数，结果每一次都是3，原因在于三次赋值的函数都共享了相同的[[scope]],寻找变量i的时候，其实访问都是同一个。都在Global.VO中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var data = [];
for(var i = 0 ; i &amp;lt; 3; i++){
    data[i]=function() {
        console.log(i);
    }
}
data[0]();//get 3
data[1]();//get 3
data[2]();//get 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用闭包，改进之后。创建新函数的时候，[[scope]]都会加上匿名外面匿名函数的AO,进而获得传进来的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var data = [];

for(var i = 0 ; i &amp;lt; 3; i++){
    data[i]=(function(x) {
        return function  () {
            console.log(x);
        }
    })(i);
}

data[0]();
data[1]();
data[2]();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;this&quot;&gt;This&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt; 是context中的一个属性，并不属于任何变量，因此也不能被赋值。在全局环境中，this就表示global.在函数中，this的值取决于调用当前函数的context.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;以上是JavaScript中几个基本的但是很重要的概念，有助于理解它的基本运行机制。此外还有一些重要的概念，比如函数、原型链、事件机制等。本文大部分参考了 Dmitry Soshnikov 的&lt;a href=&quot;http://dmitrysoshnikov.com/&quot;&gt;ECMA-262 Series&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;

</description>
				<pubDate>Wed, 26 Feb 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/02/26/javascript-basic.html</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/02/26/javascript-basic.html</guid>
			</item>
		
			<item>
				<title>创业时，我们在知乎上聊什么</title>
				<description>&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/zhihu_cover.jpg&quot; alt=&quot;logo&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;书封面&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;知乎&lt;/h3&gt;

&lt;p&gt;利用寒假在家的时间，读了这本『创业时，我们在知乎上聊什么』，这是一本来自于问答社区专题上知识集合。目前的互联网情况下，实属不易，知乎是一个优秀的互联网产品。想想自己逛知乎也一年多了，相比其他社交网络，在这里学到的东西是最多的，与其说『学习』，不如说是『了解』。这里汇集了很多领域的『牛人』，他们大多对于很多问题有自己的思考，并且在某个领域上有很深的积累。我之前建议过，每一个大一新生都应该学会使用印象笔记和浏览知乎。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;关于这本书&lt;/h3&gt;

&lt;p&gt;如果抱着凭借这本书去创业的想法，那么多半会失望。因为如其名，它应该的是一次Talk，或许这些创业践行者们坐在咖啡馆里，一下午就聊完了。幸运的是，作为读者，我们也可以旁听一下，这个资源就显得很珍贵。我想，创业也没有一本教科书，所以在学习经验的时候，Fail 就比 Success更有价值。&lt;/p&gt;

&lt;p&gt;书中把创业里的种子期，助跑期，起步期，加速期四个阶段常见的问题进行归类，在有些问题中补充了很多概念。特别是融资的部分，每一个概念其实都可以扩展很多的内容，这本书的里，是知道有这么个概念。总之，不管是否打算创业，这本书是值得一读的~&lt;/p&gt;

&lt;p&gt;细心的你会发现每本书还有唯一编号。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;创业&lt;/h3&gt;

&lt;p&gt;我并没有毕业马上就创业的打算，但是一直喜欢Startup的那种氛围，因为能充满热情的做自己喜欢的事情，玩自己喜欢的技术在学校是件非常酷的事情，如书中很多作者说的一样，创业最初就是一种态度。Waht do you want? Just do it.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;笔记&lt;/h3&gt;
&lt;p&gt;下图是读书之余整理的笔记，参照书中的目录结构。其中，去掉了几个比较小的章节，并不代表不重要，只是自己不感兴趣，或者内容更偏向主观。关于如何使用数据的部分，加上一些自己的理解，就是使用『维度』看数据，之前在北京和同学们分享过一次，锻炼分析数据的能力，可以从一个小例子做起，假如你拥有百度所有的Query数据和搜索引擎的Log日志，你能做哪些好玩的事情呢~&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;图片较大，可以右键–新的标签页打开，放大&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/%E5%88%9B%E4%B8%9A%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E7%9F%A5%E4%B9%8E%E8%81%8A%E4%BB%80%E4%B9%88.png&quot; alt=&quot;l笔记&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;读书笔记&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;推荐资料：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://book.douban.com/subject/25800616/&quot;&gt;图书豆瓣地址&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#&quot;&gt;我的笔记&lt;/a&gt; (我整理的思维导图笔记)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Mon, 10 Feb 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/write/2014/02/10/startup-zhihu.html</link>
				<guid isPermaLink="true">http://atleeon.com/write/2014/02/10/startup-zhihu.html</guid>
			</item>
		
	</channel>
</rss>